/*******************************************************************************
*
* E M B E D D E D   W I Z A R D   P R O J E C T
*
*                                                Copyright (c) TARA Systems GmbH
*                                    written by Paul Banach and Manfred Schweyer
*
********************************************************************************
*
* This software and related documentation ("Software") are intellectual
* property owned by TARA Systems and are copyright of TARA Systems.
* Any modification, copying, reproduction or redistribution of the Software in
* whole or in part by any means not in accordance with the End-User License
* Agreement for Embedded Wizard is expressly prohibited. The removal of this
* preamble is expressly prohibited.
* 
********************************************************************************
*
* DESCRIPTION:
*   This file contains the implementation of a font resource provider intended
*   to load pre-rasterized and compressed font resources directly from the code
*   memory as it will be generated by Embedded Wizard resource converters.
*
*******************************************************************************/

#include "ewrte.h"
#include "ewextfnt.h"
#include "ewgfxdriver.h"
#include "ewextgfx.h"
#include "ewgfxdefs.h"


/* The following function searches for an entry within the given aRanges array.
   The function evaluates the entries and returns the pointer to the one, which
   encloses the character code aCode. */
static const XFntRangeRes* FindGlyphRange( unsigned short aCode, 
  int aLangId, const XFntRangeRes* aRanges, int aCount );


/* The following helper function searches the glyphs array aGlyphs for the 
   glyph for the given character code. */
static const XFntGlyphRes* FindFntGlyph( unsigned short aCharCode, 
  const XFntGlyphRes* aGlyphs, int aCount );


/* The following function decompresses aCount bits from the bit stream aSrc
   starting at the position aOffset and stores the decompressed data in the
   memory area aDest. The parameter aWidth and aHeight determine the resulting
   size of the glyph. */
static void Decompress1( const unsigned int* aSrc, XSurfaceMemory* aDest,
  int aWidth, int aHeight, int aOffset, int aCount );


/* The following function decompresses aCount bits from the bit stream aSrc
   starting at the position aOffset and stores the decompressed data in the
   memory area aDest. The parameter aWidth and aHeight determine the resulting
   size of the glyph. */
static void Decompress2( const unsigned int* aSrc, XSurfaceMemory* aDest,
  int aWidth, int aHeight, int aOffset, int aCount );


/* The following function decompresses aCount bits from the bit stream aSrc
   starting at the position aOffset and stores the decompressed data in the
   memory area aDest. The parameter aWidth and aHeight determine the resulting
   size of the glyph. */
static void Decompress4( const unsigned int* aSrc, XSurfaceMemory* aDest,
  int aWidth, int aHeight, int aOffset, int aCount );


/* The following helper function combines the pixel of upper rows with the 
   pixel of the lower rows. */
static void XOrRows( XSurfaceMemory* aDest, int aWidth, int aHeight );


/* The following function processes the curve data specified in aStartCurves..
   aEndCurves and rasters from the available information a glyph bitmap in
   memory aMemory. Returns != 0 if successful. */
static int RasterGlyph( XSurfaceMemory* aMemory, const XFntGlyphRes* aGlyph,
  int aFontWidth, int aFontHeight, short aVecH, const short* aCurvesStart,
  const short* aCurvesEnd );


/* Following variables describe Flash memory which is not directly accessible
   by the CPU. In order to read the Flash memory, a user own reader procedure
   is used. Please see the function EwRegisterFlashAreaReader(). */
extern XFlashAreaReaderProc EwFlashAreaReaderProc;
extern void*                EwFlashAreaStartAddress;
extern void*                EwFlashAreaEndAddress;
extern int                  EwFlashAreaBlockSize;


/* Helper macro to test whether the given address is lying in not directly
   accessible memory area. */
#define USE_FLASH_READER( aAddress )                                           \
  ( EwFlashAreaReaderProc &&                                                   \
  ((const void*)(aAddress) >= EwFlashAreaStartAddress ) &&                     \
  ((const void*)(aAddress) <= EwFlashAreaEndAddress  ))


#ifdef EW_USE_BLOB_DATA
  /* Following variable describes the start address to access an external BLOB
     contents. Please see the function EwSetBlobData(). */
  extern const char* EwBlobStartAddress;

  /* Helper macro to read a pointer from the XFntRes data structure. The macro
     automatically distinguish between the structure stored in code or BLOB
     memory. */
  #define RES_PTR( aMember )                                                   \
    ( isBlob?                                                                  \
    ( EwBlobStartAddress + ((const XBlobFntRes*)res)->aMember ) :              \
    (const char*)res->aMember )

  /* Helper macro to read a pointer from the XFntEntryRes data structure. The
     macro automatically distinguish between the structure stored in code or
     BLOB memory. */
  #define ENTRY_PTR( aMember )                                                 \
    ( isBlob?                                                                  \
    ( EwBlobStartAddress + ((const XBlobFntEntryRes*)entry)->aMember ) :       \
    (const char*)entry->aMember )

  /* Helper macro to read a pointer from the XFntDataRes data structure. The
     macro automatically distinguish between the structure stored in code or
     BLOB memory. */
  #define FNT_PTR( aMember )                                                   \
    ( isBlob?                                                                  \
    ( EwBlobStartAddress + ((const XBlobFntDataRes*)fnt)->aMember ) :          \
    (const char*)fnt->aMember )
#else
  /* Helper macro to read a pointer from the XBmpRes data structure. The macro
     automatically distinguish between the structure stored in code or BLOB
     memory. */
  #define RES_PTR( aMember )                                                   \
    ((const char*)res->aMember )

  /* Helper macro to read a pointer from the XFntEntryRes data structure. The
     macro automatically distinguish between the structure stored in code or
     BLOB memory. */
  #define ENTRY_PTR( aMember )                                                 \
    ((const char*)entry->aMember )

  /* Helper macro to read a pointer from the XFntDataRes data structure. The
     macro automatically distinguish between the structure stored in code or
     BLOB memory. */
  #define FNT_PTR( aMember )                                                   \
    ((const char*)fnt->aMember )
#endif /* EW_USE_BLOB_DATA */


/* Helper function to get the pointer to the name associated to the resource. */
static const char* GetResourceName( const XFntRes* aResource );


/* These global variables store the number of bytes occupied by Chora objects */
extern int EwObjectsMemory;
extern int EwStringsMemory;
extern int EwResourcesMemory;
extern int EwResourcesMemoryPeak;
extern int EwMemoryPeak;


/*******************************************************************************
* FUNCTION:
*   EwFntInit
*
* DESCRIPTION:
*   The function EwFntInit() is called during the initialization of the Graphics
*   Engine. Its intention is to give the external loader a chance to initialize
*   its private variables and to start the TrueType font engine functionality
*   (if any).
*
* ARGUMENTS:
*   aArgs - User argument passed in the EwInitGraphicsEngine().
*
* RETURN VALUE:
*   If successful, returns != 0.
*
*******************************************************************************/
int EwFntInit( void* aArgs )
{
  EW_UNUSED_ARG( aArgs );
  return 1;
}


/*******************************************************************************
* FUNCTION:
*   EwFntDone
*
* DESCRIPTION:
*   The function EwFntDone() will be called during the shutdown of the Graphics
*   Engine. It gives the loader a chance to deinitialize itself just before the
*   Graphics Engine terminates.
*
* ARGUMENTS:
*   None
*
* RETURN VALUE:
*   None
*
*******************************************************************************/
void EwFntDone( void )
{
}


/*******************************************************************************
* FUNCTION:
*   EwFntGetResource
*
* DESCRIPTION:
*   The function EwFntGetResource() has the job to find or create a new resource
*   descriptor matching the attributes specified in the function parameters. The
*   returned resource can thereupon be passed to EwLoadFont() function in order
*   to use the font.
*
*   Please note: this function allows the caller to flexibly create fonts on
*   target systems supporting a TrueType font engine. In the case, you are using
*   the version without TrueType font engine integration, all fonts are already
*   stored as prerasterized glyphs. Dynamic creation of a font with different
*   attributes is in such case not possible and the function will return null.
*
* ARGUMENTS:
*   aName        - A unique name of the TrueType font stored as zero terminated
*     ASCII string (e.g. "Arial"). The function limits the evaluation to the
*     first 31 characters from the string.
*   aHeight      - The desired height of the font in pixel.
*   aBold        - This parameter determines, whether a bold or a normal style
*     of the font should be used at the runtime. A bold font will be used if
*     this parameter contains a value != 0.
*   aItalic      - This parameter determines, whether an italic or a normal
*     style of the font should be used at the runtime. An italic font is used
*     if this parameter contains a value != 0.
*   aAspectRatio - The AspectRatio parameter defines the desired aspect ratio
*     of the font in the range from 0.25 to 4.0. The default value is 1.0 - in
*     this case the aspect ratio of the font corresponds to the origin design
*     of the font.
*   aNoOfColors  - Desired quality of the font glyphs to raster. Only the 
*     values 2, 4 or 16 are valid.
*   aKerning     - Determines whether kerning data should be used for this
*     font. In such case the value has to be != 0.
*   aRowDistance - The desired distance between two consecutive text rows. If
*     the value is == 0, the distance is calculated on the base of the font
*     metrics.
*   aPopularMode - If != 0, calculate the font size similarly to how other
*     application it does. If == 0, the mode compatible to older Embedded
*     Wizard version is used.
*
* RETURN VALUE:
*   Returns a pointer to a data structure representing the font resource. If
*   the target system does not support the dynamic font creation, the function
*   will return null.
*
*******************************************************************************/
const struct XFntRes* EwFntGetResource( const char* aName, int aHeight,
  int aBold, int aItalic, float aAspectRatio, int aNoOfColors, int aKerning,
  int aRowDistance, int aPopularMode )
{
  EW_UNUSED_ARG( aName );
  EW_UNUSED_ARG( aHeight );
  EW_UNUSED_ARG( aBold );
  EW_UNUSED_ARG( aItalic );
  EW_UNUSED_ARG( aAspectRatio );
  EW_UNUSED_ARG( aNoOfColors );
  EW_UNUSED_ARG( aKerning );
  EW_UNUSED_ARG( aRowDistance );
  EW_UNUSED_ARG( aPopularMode );

  return 0;
}


/*******************************************************************************
* FUNCTION:
*   EwFntOpen
*
* DESCRIPTION:
*   The function EwFntOpen() will be called by the Graphics Engine in order to
*   initiate the access to the given font resource. Depending on the manner,
*   the resources are handled in the particular platform system, the function
*   can open a TrueType file or it can access font information available in the
*   code memory.
*
*   The function should return a handle to the opened resource. By using this
*   handle, the font content and its metrics can be requested by the Graphics
*   Engine without taking in account any platform specific aspects.
*
* ARGUMENTS:
*   aResource - Descriptor of the font resource to open. The content of this
*     descriptor depends on the particular platform system.
*
* RETURN VALUE:
*   If sucessful, the function returns the handle to the opened font resource.
*   If failed, the function returns null.
*
*******************************************************************************/
void* EwFntOpen( const struct XFntRes* aResource )
{
  const XFntRes* res      = aResource;
  #ifdef EW_USE_BLOB_DATA
    int          isBlob   = res->MagicNo == EW_MAGIC_NO_FONT_BLOB;
  #endif
  int            i;

  /* Verify, whether the binary resource does fit to this loader */
  if (( aResource->MagicNo != EW_MAGIC_NO_FONT      ) &&
      ( aResource->MagicNo != EW_MAGIC_NO_FONT_BLOB ))
  {
    EwError( 207 );
    EwPanic();
    return 0;
  }

  /* Evaluate all fonts associated to the font resource. */
  for ( i = 0; i < res->NoOfFonts; i++ )
  {
    const XFntEntryRes* entry     = (const XFntEntryRes*)RES_PTR( Fonts ) + i;
    int                 useReader = USE_FLASH_READER( entry );
    const unsigned int* magicNo;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( useReader )
      entry = (const XFntEntryRes*)EwFlashAreaReaderProc( entry, sizeof( *entry ));

    /* Read configuration parameters of the referenced font */
    magicNo = (const unsigned int*)ENTRY_PTR( Font );

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( useReader && magicNo )
      magicNo = (const unsigned int*)EwFlashAreaReaderProc( magicNo, sizeof( int ));

    /* Valid resource content */
    if ( !magicNo || (( *magicNo != EW_MAGIC_NO_BMP_FONT ) && 
                      ( *magicNo != EW_MAGIC_NO_VEC_FONT )))
    {
      EwError( 640 );
      EwPanic();
      return 0;
    }

    /* If path (vector graphic) functionality is excluded from the Graphics
       Engine, verify whether none of the referenced fonts is a vector font. */
    #ifdef EW_DONT_USE_PATH_FUNCTIONS
      if ( *magicNo == EW_MAGIC_NO_VEC_FONT )
        EwErrorSD( 641, GetResourceName( aResource ), 0 );
    #endif
  }

  /* This interface works with the original data structure as it was stored in
     the code memory */
  return (void*)aResource;
}


/*******************************************************************************
* FUNCTION:
*   EwFntClose
*
* DESCRIPTION:
*   The function EwFntClose() will be called by the Graphics Engine to finish
*   the processing of a font resource. Depending on the manner, the resources
*   are handled in the particular platform system, the function can close the
*   previously opened file and free any temporarily reserved resources.
*
* ARGUMENTS:
*   aHandle - Handle to the font resource to terminate the access.
*
* RETURN VALUE:
*   None
*
*******************************************************************************/
void EwFntClose( void* aHandle )
{
  EW_UNUSED_ARG( aHandle );
}


/*******************************************************************************
* FUNCTION:
*   EwFntGetResourceName
*
* DESCRIPTION:
*   The function EwFntGetResourceName() will be called by the Graphics Engine in
*   order to query the name of the corresponding font resource member. This name
*   is used to display error messages and warnings.
*
*   The function should return a pointer to a zero terminated char string.
*
* ARGUMENTS:
*   aHandle - Handle of the font resource to query its name.
*
* RETURN VALUE:
*   If sucessful, the function returns the pointer to the char string.
*
*******************************************************************************/
const char* EwFntGetResourceName( void* aHandle )
{
  return GetResourceName((const XFntRes*)aHandle );
}


/*******************************************************************************
* FUNCTION:
*   EwFntGetCacheSearchTag
*
* DESCRIPTION:
*   The function EwFntGetCacheSearchTag() will be called by the Graphics Engine
*   in order to query a tag identifying uniquely the font within the font glyph
*   cache.
*
*   In case of multiple variants of a font resource differing only in character
*   code mapping, the function should return a tag common for all variants of
*   the font. This will promote the reusage of the glyphs in the glyph cache.
*
* ARGUMENTS:
*   aHandle - Handle of the font resource to query the search tag.
*
* RETURN VALUE:
*   If sucessful, the function returns the search tag associated to the font.
*
*******************************************************************************/
const void* EwFntGetCacheSearchTag( void* aHandle )
{
  const XFntRes* res    = (const XFntRes*)aHandle;
  #ifdef EW_USE_BLOB_DATA
    int          isBlob = res->MagicNo == EW_MAGIC_NO_FONT_BLOB;
  #endif

  return RES_PTR( Fonts );
}


/*******************************************************************************
* FUNCTION:
*   EwFntGetMetrics
*
* DESCRIPTION:
*   The function EwFntGetMetrics() will be called by the Graphics Engine to get
*   the general attributes of the font resource. By using of these attributes,
*   Graphics Engine can create and initialize new font instances.
*
* ARGUMENTS:
*   aHandle   - Handle to the font resource to determine its attributes.
*   aAscent,
*   aDescent,
*   aLeading  - Pointers to variables, where the font metrics will be returned.
*
* RETURN VALUE:
*   If sucessful, the function returns != 0.
*
*******************************************************************************/
int EwFntGetMetrics( void* aHandle, int* aAscent, int* aDescent, int* aLeading )
{
  const XFntRes* res            = (const XFntRes*)aHandle;
  #ifdef EW_USE_BLOB_DATA
    int          isBlob         = res->MagicNo == EW_MAGIC_NO_FONT_BLOB;
  #endif
  int            ascent         = 0;
  int            descent        = 0;
  int            leading        = 0;
  int            useRowDistance = 0;
  int            accRowDistance = 0;
  int            i;

  /* Evaluate all fonts associated to the font resource. */
  for ( i = 0; i < res->NoOfFonts; i++ )
  {
    const XFntEntryRes* entry       = (const XFntEntryRes*)RES_PTR( Fonts ) + i;
    int                 useReader   = USE_FLASH_READER( entry );
    const char*         fontPtr;
    const unsigned int* magicNo;
    int                 rowDistance;
    int                 height;
    int                 popularMode;
    int                 fntAscent   = 0;
    int                 fntDescent  = 0;
    int                 fntLeading  = 0;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( useReader )
      entry = (const XFntEntryRes*)EwFlashAreaReaderProc( entry, sizeof( *entry ));

    /* Read configuration parameters of the referenced font */
    fontPtr     = ENTRY_PTR( Font );
    magicNo     = (const unsigned int*)fontPtr;
    height      = entry->Height;
    popularMode = entry->PopularMode;
    rowDistance = entry->RowDistance;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( useReader && magicNo )
      magicNo = (const unsigned int*)EwFlashAreaReaderProc( magicNo, sizeof( int ));

    /* The affected font is pre-rasterized - Get its metrics */
    if ( magicNo && ( *magicNo == EW_MAGIC_NO_BMP_FONT ))
    {
      const XFntDataRes* fnt = (const XFntDataRes*)fontPtr;

      /* Not directly accessible memory area? Map the content in CPU address space. */
      if ( useReader )
        fnt = (const XFntDataRes*)EwFlashAreaReaderProc( fnt, sizeof( *fnt ));

      fntAscent  = fnt->Ascent;
      fntDescent = fnt->Descent;
      fntLeading = fnt->Leading;
    }

    /* The affected font contains vector information - Get its metrics */
    else if ( magicNo && ( *magicNo == EW_MAGIC_NO_VEC_FONT ))
    {
      const XFntDataRes* fnt = (const XFntDataRes*)fontPtr;
      short              vecH;

      /* Not directly accessible memory area? Map the content in CPU address space. */
      if ( useReader )
        fnt = (const XFntDataRes*)EwFlashAreaReaderProc( fnt, sizeof( *fnt ));

      vecH = fnt->Ascent + fnt->Descent - ( popularMode? fnt->Accent : 0 );

      fntAscent  = (( height * fnt->Ascent  ) + ( vecH >> 1 )) / vecH;
      fntDescent = (( height * fnt->Descent ) + ( vecH >> 1 )) / vecH;
      fntLeading = (( height * fnt->Leading ) + ( vecH >> 1 )) / vecH;
    }

    /* Track if it should take the accumulated row distance value in account */
    useRowDistance |= ( rowDistance > 0 );

    /* If there is no explicit row distance value specified -> use metrics. */
    if ( !rowDistance )
      rowDistance = fntAscent + fntDescent + fntLeading;

    /* Track the max. row distance value */
    if ( rowDistance > accRowDistance )
      accRowDistance = rowDistance;

    /* Combine the metrics of fonts to single 'virtual font metrics' */
    if ( ascent  < fntAscent  ) ascent  = fntAscent;
    if ( descent < fntDescent ) descent = fntDescent;
    if ( leading < fntLeading ) leading = fntLeading;
  }

  /* If the user has specified the row distance for at least one of the fonts
     involved in the resource - calculate the necessary external leading to
     produce text outputs with this distance. */
  if ( useRowDistance )
    leading = accRowDistance - ascent - descent;

  *aAscent  = ascent;
  *aDescent = descent;
  *aLeading = leading;

  return 1;
}


/*******************************************************************************
* FUNCTION:
*   EwFntGetGlyphMetrics
*
* DESCRIPTION:
*   The function EwFntGetGlyphMetrics() will be called by the Graphics Engine in
*   order to obtain the metrics of a single glyph from the given font.
*
* ARGUMENTS:
*   aHandle   - Handle to the font resource to determine its attributes.
*   aGlyphId  - ID of the glyph to be inspected.
*   aOriginX,
*   aOriginY  - Pointers to variables, where the origin offset in pixel of the
*     desired glyph will be returned.
*   aWidth,
*   aHeight   - Pointers to variables, where the size in pixel of the glyph will
*     be returned.
*   aAdvance  - Pointer to a variable, where the horizontal advance in pixel for
*     the glyph will be returned.
*
* RETURN VALUE:
*   If sucessful, the function returns != 0.
*
*******************************************************************************/
int EwFntGetGlyphMetrics( void* aHandle, unsigned int aGlyphId,
  int* aOriginX, int* aOriginY, int* aWidth, int* aHeight, int* aAdvance )
{
  const XFntRes*      res     = (const XFntRes*)aHandle;
  #ifdef EW_USE_BLOB_DATA
    int               isBlob  = res->MagicNo == EW_MAGIC_NO_FONT_BLOB;
  #endif
  int                 fontNo  = aGlyphId >> 24;
  int                 glyphId = aGlyphId & 0x00FFFFFF;
  const XFntEntryRes* entry;
  const char*         fontPtr;
  const unsigned int* magicNo;
  int                 width;
  int                 height;
  int                 popularMode;

  /* The glyph Id does not belong to any of the included fonts. */
  if ( fontNo >= res->NoOfFonts )
    return 0;

  /* Entry containing the reference to the corresponding font data */
  entry = (const XFntEntryRes*)RES_PTR( Fonts ) + fontNo;

  /* Not directly accessible memory area? Map the content in CPU address space. */
  if ( USE_FLASH_READER( entry ))
    entry = (const XFntEntryRes*)EwFlashAreaReaderProc( entry, sizeof( *entry ));

  /* Read configuration parameters of the referenced font */
  fontPtr     = ENTRY_PTR( Font );
  magicNo     = (const unsigned int*)fontPtr;
  width       = entry->Width;
  height      = entry->Height;
  popularMode = entry->PopularMode;

  /* Not directly accessible memory area? Map the content in CPU address space. */
  if ( magicNo && USE_FLASH_READER( magicNo ))
    magicNo = (const unsigned int*)EwFlashAreaReaderProc( magicNo, sizeof( int ));

  /* The affected font is pre-rasterized */
  if ( magicNo && ( *magicNo == EW_MAGIC_NO_BMP_FONT ))
  {
    const XFntDataRes*  fnt = (const XFntDataRes*)fontPtr;
    const XFntGlyphRes* glyph;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( USE_FLASH_READER( fnt ))
      fnt = (const XFntDataRes*)EwFlashAreaReaderProc( fnt, sizeof( *fnt ));

    /* Is the glyph id valid? */
    if ( glyphId >= fnt->NoOfGlyphs )
      return 0;

    /* Access the glyph */
    glyph = (const XFntGlyphRes*)FNT_PTR( Glyphs ) + glyphId;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( USE_FLASH_READER( glyph ))
      glyph = (const XFntGlyphRes*)EwFlashAreaReaderProc( glyph, sizeof( *glyph ));

    *aOriginX = glyph->OriginX;
    *aOriginY = glyph->OriginY;
    *aWidth   = glyph->Width;
    *aHeight  = glyph->Height;
    *aAdvance = glyph->Advance;

    return 1;
  }

  /* The affected font contains vector information */
  else if ( magicNo && ( *magicNo == EW_MAGIC_NO_VEC_FONT ))
  {
    const XFntDataRes*  fnt = (const XFntDataRes*)fontPtr;
    const XFntGlyphRes* glyph;
    short               vecH;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( USE_FLASH_READER( fnt ))
      fnt = (const XFntDataRes*)EwFlashAreaReaderProc( fnt, sizeof( *fnt ));

    /* Is the glyph id valid? */
    if ( glyphId >= fnt->NoOfGlyphs )
      return 0;

    /* Access the glyph */
    glyph = (const XFntGlyphRes*)FNT_PTR( Glyphs ) + glyphId;
    vecH  = fnt->Ascent + fnt->Descent - ( popularMode? fnt->Accent : 0 );

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( USE_FLASH_READER( glyph ))
      glyph = (const XFntGlyphRes*)EwFlashAreaReaderProc( glyph, sizeof( *glyph ));

    *aOriginX = (( width  * glyph->OriginX ) + ( vecH >> 1 )) / vecH;
    *aOriginY = (( height * glyph->OriginY ) - ( vecH >> 1 )) / vecH;
    *aWidth   = (( width  * glyph->Width   ) + ( vecH >> 1 )) / vecH;
    *aHeight  = (( height * glyph->Height  ) + ( vecH >> 1 )) / vecH;
    *aAdvance = (( width  * glyph->Advance ) + ( vecH >> 1 )) / vecH;

    /* Sometimes the glyph curve data affects more pixel than specified in the
       metric. Addition pixel rows or columns around the glyph are affected. To
       avoid ugly looking (clipped) glyphs enhance the glyph area accordingly */
    if (( *aWidth > 0 ) && ( *aHeight > 0 ))
    {
      *aWidth   += 2;
      *aHeight  += 2;
      *aOriginX -= 1;
      *aOriginY -= 1;
    }

    return 1;
  }

  return 0;
}


/*******************************************************************************
* FUNCTION:
*   EwFntGetKerning
*
* DESCRIPTION:
*   The function EwFntGetKerning() will be called by the Graphics Engine in
*   order to obtain the kerning value for the pair of two glyphs from the given
*   font.
*
* ARGUMENTS:
*   aHandle   - Handle to the font resource to determine the kerning.
*   aGlyphId1 - ID of the first glyph.
*   aGlyphId2 - ID of the second glyph.
*
* RETURN VALUE:
*   The function returns the kerning value for the given pair of glyphs or 0
*   if the glyphs are not affected by kerning or at least one of the glyphs is
*   not existing in the font.
*
*******************************************************************************/
int EwFntGetKerning( void* aHandle, unsigned int aGlyphId1,
  unsigned int aGlyphId2 )
{
  const XFntRes*       res       = (const XFntRes*)aHandle;
  #ifdef EW_USE_BLOB_DATA
    int                isBlob    = res->MagicNo == EW_MAGIC_NO_FONT_BLOB;
  #endif
  int                  fontNo1   = aGlyphId1 >> 24;
  int                  fontNo2   = aGlyphId2 >> 24;
  unsigned int         key       = ( aGlyphId1 & 0xFFFF ) | ( aGlyphId2 << 16 );
  const XFntEntryRes*  entry;
  const char*          fontPtr;
  const unsigned int*  magicNo;
  int                  width;
  int                  popularMode;
  short                vecH      = 0;
  const unsigned int*  codes     = 0;
  const short*         values    = 0;
  int                  foundInx  = -1;

  /* The glyphs do not belong to the same font -> no kerning */
  if ( fontNo1 != fontNo2 )
    return 0;

  /* The glyph Ids do not belong to any of the included fonts. */
  if ( fontNo1 >= res->NoOfFonts )
    return 0;

  /* Entry containing the reference to the corresponding font data */
  entry = (const XFntEntryRes*)RES_PTR( Fonts ) + fontNo1;

  /* Not directly accessible memory area? Map the content in CPU address space. */
  if ( USE_FLASH_READER( entry ))
    entry = (const XFntEntryRes*)EwFlashAreaReaderProc( entry, sizeof( *entry ));

  /* The font has to be activated for kerning */
  if ( !entry->Kerning )
    return 0;

  /* Read configuration parameters of the referenced font */
  fontPtr     = ENTRY_PTR( Font );
  magicNo     = (const unsigned int*)fontPtr;
  width       = entry->Width;
  popularMode = entry->PopularMode;

  /* Not directly accessible memory area? Map the content in CPU address space. */
  if ( magicNo && USE_FLASH_READER( magicNo ))
    magicNo = (const unsigned int*)EwFlashAreaReaderProc( magicNo, sizeof( int ));

  /* Access the kerning data */
  if ( magicNo && (( *magicNo == EW_MAGIC_NO_BMP_FONT ) ||
                   ( *magicNo == EW_MAGIC_NO_VEC_FONT )))
  {
    const XFntDataRes* fnt = (const XFntDataRes*)fontPtr;
    int                vec = *magicNo == EW_MAGIC_NO_VEC_FONT;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( USE_FLASH_READER( fnt ))
      fnt = (const XFntDataRes*)EwFlashAreaReaderProc( fnt, sizeof( *fnt ));

    codes  = (const unsigned int*)FNT_PTR( KerningCodes  );
    values = (const short*)       FNT_PTR( KerningValues );
    vecH   = vec? ( fnt->Ascent + fnt->Descent - ( popularMode? fnt->Accent : 0 )) : 0;
  }

  /* Search the codes array for the code pair */
  if ( codes )
  {
    int useReader = USE_FLASH_READER( codes );
    int inx       = 0;
    int min       = 0;
    int comp      = -1;
    int max       = 0;

    if ( codes &&  useReader ) max = *(const int*)EwFlashAreaReaderProc( codes, 0 );
    if ( codes && !useReader ) max = *(const int*)codes;

    /* No kerning information available in this font */
    if ( max <= 0 )
      return 0;

    /* The first array value stores the number entries. Skip over. Adjust the
       'max' to refer to the last entry in the array */
    codes++;
    max -= 2;

    /* Repeat until the entry affecting the both glyph is found, or the end 
       of the array is reached */
    while( max >= min )
    {
      inx  = ( max + min ) / 2;

      /* If the memory containing the kerning data is not directly accessible,
         use a reader for this purpose */
      if ( useReader )
        comp = key - *(const unsigned int*)EwFlashAreaReaderProc( codes + inx, 0 );
      else
        comp = key - codes[ inx ]; 

      /* Found? */
      if ( !comp )
      {
        foundInx = inx;
        break;
      }

      /* Continue the search operation */
      if (  comp < 0 ) max = inx - 1;
      else             min = inx + 1;
    }
  }

  /* The kerning information was found in a pre-rasterized font. Access the data */
  if (( foundInx >= 0 ) && values )
  {
    values += foundInx;

    /* If the memory containing the kerning data is not directly accessible,
       use a reader for this purpose */
    if ( USE_FLASH_READER( values ))
      values = (const short*)EwFlashAreaReaderProc( values, sizeof( short ));

    /* Scale the kerning in case of vector fonts */
    if ( vecH )
      return (( *values * width ) + ( vecH >> 1 )) / vecH;

    /* In case of pre-rasterized fonts the kernign value is already scaled */
    else
      return *values;
  }

  /* No kerning information available */
  return 0;
}


/*******************************************************************************
* FUNCTION:
*   EwFntIsGlyphAvailable
*
* DESCRIPTION:
*   The function EwFntIsGlyphAvailable() will be called by the Graphics Engine
*   in order to verify whether the given font contains a glyph for a character.
*
* ARGUMENTS:
*   aHandle   - Handle to the font resource to determine the glyph existence.
*   aCharCode - Character code of the glyph.
*
* RETURN VALUE:
*   The function returns != 0 if the glyph exists. Otherwise 0 is returned.
*
*******************************************************************************/
int EwFntIsGlyphAvailable( void* aHandle, unsigned short aCharCode )
{
  const XFntRes*      res    = (const XFntRes*)aHandle;
  #ifdef EW_USE_BLOB_DATA
    int               isBlob = res->MagicNo == EW_MAGIC_NO_FONT_BLOB;
  #endif
  const XFntRangeRes* ranges = (const XFntRangeRes*)RES_PTR( Ranges );
  const XFntRangeRes* range;
  const XFntEntryRes* entry;
  const char*         fontPtr;
  const unsigned int* magicNo;
  int                 fontNo = 0;

  /* Determine the glyph range, the desired character code belongs to. Do that
     first by limiting to the language associated to the font. */
  range = FindGlyphRange( aCharCode, res->LangId, ranges, res->NoOfRanges );

  /* If there is no range for the associated language, search for the range in
     the default language */
  if ( !range )
    range = FindGlyphRange( aCharCode, 0, ranges, res->NoOfRanges );

  /* Then get the number of the font and calculate the code of the character
     code within this font */
  if ( range )
  {
    fontNo    = range->FontNo;
    aCharCode = (unsigned short)( aCharCode + range->Offset );
  }

  /* Entry containing the reference to the corresponding font data */
  entry = (const XFntEntryRes*)RES_PTR( Fonts ) + fontNo;

  /* Not directly accessible memory area? Map the content in CPU address space. */
  if ( USE_FLASH_READER( entry ))
    entry = (const XFntEntryRes*)EwFlashAreaReaderProc( entry, sizeof( *entry ));

  /* Read configuration parameters of the referenced font */
  fontPtr = ENTRY_PTR( Font );
  magicNo = (const unsigned int*)fontPtr;

  /* Not directly accessible memory area? Map the content in CPU address space. */
  if ( magicNo && USE_FLASH_READER( magicNo ))
    magicNo = (const unsigned int*)EwFlashAreaReaderProc( magicNo, sizeof( int ));

  /* Valid font? */
  if ( magicNo && (( *magicNo == EW_MAGIC_NO_BMP_FONT ) || 
                   ( *magicNo == EW_MAGIC_NO_VEC_FONT )))
  {
    const XFntDataRes*  fnt = (const XFntDataRes*)fontPtr;
    const XFntGlyphRes* glyphs;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( USE_FLASH_READER( fnt ))
      fnt = (const XFntDataRes*)EwFlashAreaReaderProc( fnt, sizeof( *fnt ));

    glyphs = (const XFntGlyphRes*)FNT_PTR( Glyphs );
    return FindFntGlyph( aCharCode, glyphs, fnt->NoOfGlyphs ) != 0;
  }

  /* Not found */
  return 0;
}


/*******************************************************************************
* FUNCTION:
*   EwFntGetGlyphId
*
* DESCRIPTION:
*   The function EwFntGetGlyphId() will be called by the Graphics Engine in
*   order to query the glyph id for a given character.
*
* ARGUMENTS:
*   aHandle   - Handle to the font resource to determine the glyph existence.
*   aCharCode - Character code of the glyph.
*
* RETURN VALUE:
*   The function returns != 0 if the glyph exists. Otherwise 0 is returned.
*   The value 0 corresponds in this case to the '.notdef' glyph.
*
*******************************************************************************/
unsigned int EwFntGetGlyphId( void* aHandle, unsigned short aCharCode )
{
  const XFntRes*      res    = (const XFntRes*)aHandle;
  #ifdef EW_USE_BLOB_DATA
    int               isBlob = res->MagicNo == EW_MAGIC_NO_FONT_BLOB;
  #endif
  const XFntRangeRes* ranges = (const XFntRangeRes*)RES_PTR( Ranges );
  const XFntRangeRes* range;
  const XFntEntryRes* entry;
  const char*         fontPtr;
  const unsigned int* magicNo;
  int                 fontNo  = 0;
  unsigned int        glyphId = 0;

  /* Determine the glyph range, the desired character code belongs to. Do that
     first by limiting to the language associated to the font. */
  range = FindGlyphRange( aCharCode, res->LangId, ranges, res->NoOfRanges );

  /* If there is no range for the associated language, search for the range in
     the default language */
  if ( !range )
    range = FindGlyphRange( aCharCode, 0, ranges, res->NoOfRanges );

  /* Then get the number of the font and calculate the code of the character
     code within this font */
  if ( range )
  {
    fontNo    = range->FontNo;
    aCharCode = (unsigned short)( aCharCode + range->Offset );
  }

  /* Entry containing the reference to the corresponding font data */
  entry = (const XFntEntryRes*)RES_PTR( Fonts ) + fontNo;

  /* Not directly accessible memory area? Map the content in CPU address space. */
  if ( USE_FLASH_READER( entry ))
    entry = (const XFntEntryRes*)EwFlashAreaReaderProc( entry, sizeof( *entry ));

  /* Read configuration parameters of the referenced font */
  fontPtr = ENTRY_PTR( Font );
  magicNo = (const unsigned int*)fontPtr;

  /* Not directly accessible memory area? Map the content in CPU address space. */
  if ( magicNo && USE_FLASH_READER( magicNo ))
    magicNo = (const unsigned int*)EwFlashAreaReaderProc( magicNo, sizeof( int ));

  /* Valid font? */
  if ( magicNo && (( *magicNo == EW_MAGIC_NO_BMP_FONT ) || 
                   ( *magicNo == EW_MAGIC_NO_VEC_FONT )))
  {
    const XFntDataRes*  fnt = (const XFntDataRes*)fontPtr;
    const XFntGlyphRes* glyphs;
    const XFntGlyphRes* glyph;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( USE_FLASH_READER( fnt ))
      fnt = (const XFntDataRes*)EwFlashAreaReaderProc( fnt, sizeof( *fnt ));

    glyphs = (const XFntGlyphRes*)FNT_PTR( Glyphs );
    glyph  = FindFntGlyph( aCharCode, glyphs, fnt->NoOfGlyphs );

    /* If found - get the number of the glyph */
    if ( glyph )
      glyphId = (unsigned int)( glyph - glyphs );
  }

  /* Trying to obtain the soft-hyphen sign 0xAD ... but there is no matching
     glyph available. As fallback, try to return the glyph for regular hyphen
     '-' sign. */
  if ( !glyphId && ( aCharCode == 0x00AD ))
    return EwFntGetGlyphId( aHandle, '-' );

  /* Trying to obtain the non-break space sign 0xA0 ... but there is no matching
     glyph available. As fallback, try to return the glyph for regular space
     0x20 sign. */
  if ( !glyphId && ( aCharCode == 0x00A0 ))
    return EwFntGetGlyphId( aHandle, ' ' );

  /* If there is no glyph resource for the desired character */
  if ( !glyphId )
    return 0;

  /* When multiple 'real' fonts are combined together, the upper 8-bit of the
     returned glyph-id is used to select the font. The unique exception is the
     '.notdef' glyph, which is always 0. The '.notdef' glyph will thus be used
     from the first font. */
  return glyphId | ( fontNo << 24 );
}


/*******************************************************************************
* FUNCTION:
*   EwFntInitShaper
*
* DESCRIPTION:
*   The function EwFntInitShaper() is called by the Graphics Engine in order
*   to prepare a context object for the following cluster shaping process. The
*   context is used by the shaper to store state information for the already
*   processed text and depending on it to decide how to shape the following
*   clusters.
*
*   If not used anymore, the context should be freed by using EwFntDoneShaper()
*   function.
*
* ARGUMENTS:
*   None
*
* RETURN VALUE:
*   The function returns a handle to the new created shaper context object.
*
*******************************************************************************/
void* EwFntInitShaper( void )
{
  /* In the actual version there is no shaper context used. */
  return 0;
}


/*******************************************************************************
* FUNCTION:
*   EwFntDoneShaper
*
* DESCRIPTION:
*   The function EwFntDoneShaper() is called by the Graphics Engine in order
*   to release a context object used previously during shaping process. The
*   context is ceated by the function EwFntInitShaper().
*
* ARGUMENTS:
*   aHandle - Handle to the shaper context.
*
* RETURN VALUE:
*   None
*
*******************************************************************************/
void EwFntDoneShaper( void* aHandle )
{
  /* In the actual version there is no shaper context used. */
  EW_UNUSED_ARG( aHandle );
}


/*******************************************************************************
* FUNCTION:
*   EwFntResetShaper
*
* DESCRIPTION:
*   The function EwFntResetShaper() is called by the Graphics Engine in order
*   to restore the default state of the shaper context object.
*
* ARGUMENTS:
*   aHandle - Handle to the shaper context.
*
* RETURN VALUE:
*   None
*
*******************************************************************************/
void EwFntResetShaper( void* aHandle )
{
  /* In the actual version there is no shaper context used. */
  EW_UNUSED_ARG( aHandle );
}


/*******************************************************************************
* FUNCTION:
*   EwFntSaveShaper
*
* DESCRIPTION:
*   The function EwFntSaveShaper() is called by the Graphics Engine in order to
*   store the actual state of the shaper context object temporarily. To restore
*   the state again, the function EwFntRestoreShaper() is used.
*
* ARGUMENTS:
*   aHandle - Handle to the shaper context.
*
* RETURN VALUE:
*   None
*
*******************************************************************************/
void EwFntSaveShaper( void* aHandle )
{
  /* In the actual version there is no shaper context used. */
  EW_UNUSED_ARG( aHandle );
}


/*******************************************************************************
* FUNCTION:
*   EwFntRestoreShaper
*
* DESCRIPTION:
*   The function EwFntRestoreShaper() is called by the Graphics Engine in order
*   to restore the state of the shaper context object stored previously by the
*   invocation of the function EwFntSaveShaper().
*
*   Please note: When calling the function, the actual state of the shaper is
*   saved too. It is as if the saved and actual states were exchanged.
*
* ARGUMENTS:
*   aHandle - Handle to the shaper context.
*
* RETURN VALUE:
*   None
*
*******************************************************************************/
void EwFntRestoreShaper( void* aHandle )
{
  /* In the actual version there is no shaper context used. */
  EW_UNUSED_ARG( aHandle );
}


/*******************************************************************************
* FUNCTION:
*   EwFntShapeCluster
*
* DESCRIPTION:
*   The function EwFntShapeCluster() is called by the Graphics Engine in order
*   to evaluate the text (aCharCodes) looking for the next indivisible unit
*   (cluster) and convert the character codes in corresponding glyph ids. The
*   glyph ids are then returned in the array aGlyphIds.
*
*   Depending on the text found in aCharCodes and features available in the
*   font, the function may apply diverse reordering and substitution steps so
*   the returned glyphs represent the original text formatted correctly. This
*   functionality is known as 'layout shaping' or 'complex text layout'. For
*   example, the function may convert a sequence of character codes to a unique
*   glyph id representing a ligature of those characters.
*   
* ARGUMENTS:
*   aHandle        - Handle to the font resource to process the characters and
*     estimate the right glyph ids.
*   aCharCodes     - An array containing the original text as Unicode code
*     points. The maximum number of characters in this array, the function may
*     process, is determined by the parameter aNoOfCharCodes.
*     Usually, the storage order of character codes corresponds to the order
*     in which the characters are rendered on the screen from left to right.
*     This can be modified by the parameter aDirection.
*   aNoOfCharCodes - Number of characters provided in the array aCharCodes.
*   aDirection     - Provides information about the order of how characters
*     in the aCharCodes array should be evaluated. If aDirection is 0 (zero),
*     the characters are stored in the order corresponding to how the glyphs
*     are rendered from left to right direction. If aDirection is != 0, the
*     codes are stored in reversed order. This means the first character is
*     displayed on the right of the second character.
*   aGlyphIds      - An array where resulting glyph ids are stored. The
*     parameter aNoOfGlyphIds determines the capacity of this array.
*   aDeltasOriginX - An array where horizontal displacement of the resulting
*     glyphs is stored. The parameter aNoOfGlyphIds determines the capacity
*     of this array.
*   aDeltasOriginY - An array where vertical displacement of the resulting
*     glyphs is stored. The parameter aNoOfGlyphIds determines the capacity
*     of this array.
*   aDeltasAdvance - An array where horizontal displacement of the following
*     glyph position is stored. The parameter aNoOfGlyphIds determines the
*     capacity of this array.
*   aNoOfGlyphIds  - As input parameter determines the capacity of the arrays
*     aGlyphIds, aGlyphXOffsets and aGlyphYOffsets. When the function has
*     finished the processing, the parameter will store how many glyphs and
*     offsets are available in the arrays aGlyphIds, aDeltasOriginX,
*     aDeltasOriginY and aDeltasAdvance.
*   aLineEnd       - If there is a potential line end after the just shaped
*     cluster, the variable referred by aLineEnd is initialized with a value
*     != 0. If there is no line break candidate between the processed cluster
*     and next following cluster, value 0 is assigned to the variable.
*   aContext       - Handle to the shaper context containing the information
*     collected during the process of the preceding cluster. This information
*     can be used when processing a new cluster. EwFntShapeCluster() should
*     thereupon update the context.
*
* RETURN VALUE:
*   The function returns how many character codes from the array aCharCodes
*   haven been processed. If the function couldn't even process a single
*   character, the returned value is 0.
*
*******************************************************************************/
int EwFntShapeCluster( void* aHandle, 
  const unsigned short* aCharCodes, int aNoOfCharCodes, int aDirection,
  unsigned int* aGlyphIds, short* aDeltasOriginX, short* aDeltasOriginY,
  short* aDeltasAdvance, int* aNoOfGlyphIds, int* aLineEnd, void* aContext )
{
  EW_UNUSED_ARG( aContext );

  /* Nothing to process. */
  if ( aNoOfCharCodes <= 0 )
    return 0;

  /* Actually we ignore the RTL text cluster shaping treating the character
     codes stored in this RTL order as isolated units. */
  if ( aDirection )
    aNoOfCharCodes = 1;

  /* Actually there is no support for complex text layout. We process the 
     characters isolated ony by one by handling few exception cases. */
  if ( *aNoOfGlyphIds > 0 )
  {
    aGlyphIds[0]      = EwFntGetGlyphId( aHandle, aCharCodes[0]);
    aDeltasOriginX[0] = 0;
    aDeltasOriginY[0] = 0;
    aDeltasAdvance[0] = 0;
    aLineEnd[0]       = 0;

    /* Trying to obtain the non-break space sign 0xA0 ... but there is no matching
       glyph available. As fallback, try to return the glyph for regular space
       0x20 sign. */
    if ( !aGlyphIds[0] && ( aCharCodes[0] == 0x00A0 ))
      aGlyphIds[0] = EwFntGetGlyphId( aHandle, ' ' );

    /* Trying to obtain the soft-hyphen sign 0xAD ... but there is no matching
       glyph available. As fallback, try to return the glyph for regular hyphen
       '-' sign. */
    else if ( !aGlyphIds[0] && ( aCharCodes[0] == 0x00AD ))
      aGlyphIds[0] = EwFntGetGlyphId( aHandle, '-' );

    /* Trying to obtain the ellipsis sign '...' but there is no matching glyph
       available in the font. As fallback, try to return 3 regular '.' signs
       as a single cluster. */
    else if ( !aGlyphIds[0] && ( aCharCodes[0] == 0x2026 ) && ( *aNoOfGlyphIds >= 3 ))
    {
      /* Get the glyph for the '.' sign. */
      aGlyphIds[0] = EwFntGetGlyphId( aHandle, '.' );

      /* And return 3 copies of it */
      if ( aGlyphIds[0])
      {
        aGlyphIds[1]      = aGlyphIds[2]      = aGlyphIds[0];
        aDeltasOriginX[1] = aDeltasOriginX[2] = 0;
        aDeltasOriginY[1] = aDeltasOriginY[2] = 0;
        aDeltasAdvance[1] = aDeltasAdvance[2] = 0;

        *aNoOfGlyphIds = 3;
        return 1;
      }
    }

    /* One character processed and converted in glyph */
    if ( aGlyphIds[0])
    {
      *aNoOfGlyphIds = 1;
      return 1;
    }
  }

  /* No character processed */
  *aNoOfGlyphIds = 0;
  return 0;
}


/*******************************************************************************
* FUNCTION:
*   EwFntLoadGlyph
*
* DESCRIPTION:
*   The function EwFntLoadGlyph() will be called by the Graphics Engine in order
*   to load the glyph pixel data from the openend font resource aHandle into the
*   given memory area aMemory. Depending on the manner, a resource is handled in
*   the particular platform, the pixel data may be loaded from a TrueType file
*   or they can be decompressed from the code memory.
*
* ARGUMENTS:
*   aHandle  - Handle to the font resource to load its glyph pixel data.
*   aGlyphId - ID of the glyph to be loaded.
*   aMemory  - Memory descriptor containing pointers and pitch information of
*     the destination to write the glyph pixel data.
*
* RETURN VALUE:
*   If sucessful, the function returns != 0.
*
*******************************************************************************/
int EwFntLoadGlyph( void* aHandle, unsigned int aGlyphId,
  XSurfaceMemory* aMemory )
{
  const XFntRes*      res     = (const XFntRes*)aHandle;
  #ifdef EW_USE_BLOB_DATA
    int               isBlob  = res->MagicNo == EW_MAGIC_NO_FONT_BLOB;
  #endif
  int                 fontNo  = aGlyphId >> 24;
  int                 glyphId = aGlyphId & 0x00FFFFFF;
  const XFntEntryRes* entry;
  const char*         fontPtr;
  const unsigned int* magicNo;
  int                 height;
  int                 width;
  int                 popularMode;

  /* The glyph Id does not belong to any of the included fonts. */
  if ( fontNo >= res->NoOfFonts )
    return 0;

  /* Entry containing the reference to the corresponding font data */
  entry = (const XFntEntryRes*)RES_PTR( Fonts ) + fontNo;

  /* Not directly accessible memory area? Map the content in CPU address space. */
  if ( USE_FLASH_READER( entry ))
    entry = (const XFntEntryRes*)EwFlashAreaReaderProc( entry, sizeof( *entry ));

  /* Read configuration parameters of the referenced font */
  fontPtr     = ENTRY_PTR( Font );
  magicNo     = (const unsigned int*)fontPtr;
  width       = entry->Width;
  height      = entry->Height;
  popularMode = entry->PopularMode;

  /* Not directly accessible memory area? Map the content in CPU address space. */
  if ( magicNo && USE_FLASH_READER( magicNo ))
    magicNo = (const unsigned int*)EwFlashAreaReaderProc( magicNo, sizeof( int ));

  /* The affected font is pre-rasterized */
  if ( magicNo && ( *magicNo == EW_MAGIC_NO_BMP_FONT ))
  {
    const XFntDataRes*  fnt = (const XFntDataRes*)fontPtr;
    const XFntGlyphRes* glyph;
    const unsigned int* pixel;
    int                 noOfColors;
    int                 glyphWidth;
    int                 glyphHeight;
    int                 glyphPixel;
    int                 glyph1Pixel;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( USE_FLASH_READER( fnt ))
      fnt = (const XFntDataRes*)EwFlashAreaReaderProc( fnt, sizeof( *fnt ));

    /* Is the glyph id valid? */
    if ( glyphId >= fnt->NoOfGlyphs )
      return 0;

    /* Access the glyph */
    glyph      = (const XFntGlyphRes*)FNT_PTR( Glyphs ) + glyphId;
    pixel      = (const unsigned int*)FNT_PTR( Data );
    noOfColors = fnt->NoOfColors;

    /* The metric information is stored in a not directly accessible memory area.
       Use the reader to copy this information. */
    if ( USE_FLASH_READER( glyph ))
      glyph = (const XFntGlyphRes*)EwFlashAreaReaderProc( glyph, 2 * sizeof( *glyph ));

    glyphWidth  = glyph->Width;
    glyphHeight = glyph->Height;
    glyphPixel  = glyph->Data;
    glyph1Pixel = glyph[1].Data;

    /* No decompression necessary because there is no pixel data for the glyph */
    if ( !glyphWidth || !glyphHeight )
      return 1;

    /* Decompress the pixel information of the glyph ... */
    switch ( noOfColors )
    {
      case 2 :
        Decompress1( pixel, aMemory, glyphWidth, glyphHeight, glyphPixel,
                     glyph1Pixel - glyphPixel );
      break;
      case 4 :
        Decompress2( pixel, aMemory, glyphWidth, glyphHeight, glyphPixel,
                     glyph1Pixel - glyphPixel );
      break;
      case 16 :
        Decompress4( pixel, aMemory, glyphWidth, glyphHeight, glyphPixel,
                     glyph1Pixel - glyphPixel );
      break;
    }

    /* Now,XOR the consecutive rows within the glyph. */
    XOrRows( aMemory, glyphWidth, glyphHeight );

    return 1;
  }

  /* The affected font contains vector information */
  else if ( magicNo && ( *magicNo == EW_MAGIC_NO_VEC_FONT ))
  {
    const XFntDataRes*  fnt = (const XFntDataRes*)fontPtr;
    const XFntGlyphRes* glyph;
    const char*         curves;
    int                 glyphCurves;
    int                 glyph1Curves;
    short               vecH;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( USE_FLASH_READER( fnt ))
      fnt = (const XFntDataRes*)EwFlashAreaReaderProc( fnt, sizeof( *fnt ));

    /* Is the glyph id valid? */
    if ( glyphId >= fnt->NoOfGlyphs )
      return 0;

    /* Access the glyph */
    glyph  = (const XFntGlyphRes*)FNT_PTR( Glyphs ) + glyphId;
    curves = FNT_PTR( Data );
    vecH   = fnt->Ascent + fnt->Descent - ( popularMode? fnt->Accent : 0 );

    /* The metric information is stored in a not directly accessible memory area.
       Use the reader to copy this information. */
    if ( USE_FLASH_READER( glyph ))
      glyph = (const XFntGlyphRes*)EwFlashAreaReaderProc( glyph, 2 * sizeof( *glyph ));

    glyphCurves  = glyph->Data;
    glyph1Curves = glyph[1].Data;

    /* No decompression necessary because there is no curve data for the glyph */
    if (( glyph->Width <= 0 ) || ( glyph->Height <= 0 ) ||
        ( glyphCurves >= glyph1Curves ))
      return 1;

    /* Raster the curves describing the glyph inside the bitmap aMemory */
    return RasterGlyph( aMemory, glyph, width, height, vecH, 
                      (const short*)( curves + glyphCurves ),
                      (const short*)( curves + glyph1Curves ));
  }

  return 0;
}


/* A table used as a node tree for the decompression. */
static const unsigned char Tree[ 15 ][ 2 ] =
{
  { 0x10, 0x01 },
  { 0x02, 0x05 },
  { 0x03, 0x04 },
  { 0x11, 0x12 },
  { 0x14, 0x18 },
  { 0x06, 0x09 },
  { 0x07, 0x08 },
  { 0x13, 0x16 },
  { 0x17, 0x1C },
  { 0x0A, 0x0B },
  { 0x1E, 0x1F },
  { 0x0C, 0x0D },
  { 0x15, 0x19 },
  { 0x1A, 0x0E },
  { 0x1B, 0x1D }
};


/* The following function searches for an entry within the given aRanges array.
   The function evaluates the entries and returns the pointer to the one, which
   encloses the character code aCode. */
static const XFntRangeRes* FindGlyphRange( unsigned short aCharCode, 
  int aLangId, const XFntRangeRes* aRanges, int aCount )
{
  const XFntRangeRes* end       = aRanges + aCount;
  int                 useReader = USE_FLASH_READER( aRanges );

  /* Search the list of ranges for an entry containing aCharCode and the language */
  for ( ; aRanges < end; aRanges++ )
  {
    const XFntRangeRes* range = aRanges;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( useReader )
      range = (const XFntRangeRes*)EwFlashAreaReaderProc( range, sizeof( *range ));

    /* Found? */
    if (( aLangId == range->LangId ) && ( aCharCode >= range->First ) &&
        ( aCharCode <= range->Last ))
      return range;
  }

  /* Not found */
  return 0;
}


/* The following helper function searches the glyphs array aGlyphs for the 
   glyph for the given character code. */
static const XFntGlyphRes* FindFntGlyph( unsigned short aCharCode, 
  const XFntGlyphRes* aGlyphs, int aCount )
{
  int index     = 0;
  int min       = 0;
  int max       = aCount - 1;
  int comp      = -1;
  int useReader = USE_FLASH_READER( aGlyphs );
  
  /* repeat until the desired glyph resource is found, or the end of the 
     array is reached */
  while( max >= min )
  {
    index = ( max + min ) / 2;

    /* If the memory containing the metric data is not directly accessible,
       use a reader for this purpose */
    if ( useReader )
      comp  = aCharCode - *(const unsigned short*)EwFlashAreaReaderProc( 
                                                 &aGlyphs[ index ].CharCode, 0 );
    else
      comp  = aCharCode - aGlyphs[ index ].CharCode;

    /* found? */
    if ( !comp )
      return &aGlyphs[ index ];

    /* otherwise confine the search to the upper half of the array */
    if ( comp > 0 )
      min = index + 1 ;

    /* or to the lower half */
    else if ( comp < 0 )
      max = index - 1;
  }

  /* not found */
  return 0;
}


/* The following function decompresses aCount bits from the bit stream aSrc
   starting at the position aOffset and stores the decompressed data in the
   memory area aDest. The parameter aWidth and aHeight determine the resulting
   size of the glyph. */
static void Decompress1( const unsigned int* aSrc, XSurfaceMemory* aDest,
  int aWidth, int aHeight, int aOffset, int aCount )
{
  unsigned int        data;
  int                 inx       = 0;
  const unsigned int* src       = aSrc;
  unsigned char*      dest      = aDest->Pixel1;
  int                 pitch     = aDest->Pitch1Y;
  int                 ofs       = 0;
  int                 size      = aWidth * aHeight;
  int                 useReader = EwFlashAreaReaderProc && 
                                   ((void*)aSrc >= EwFlashAreaStartAddress ) && 
                                   ((void*)aSrc <= EwFlashAreaEndAddress );

  /* Determinate the address of the data word where the compressed bit-
     stream begins and calculate the offset to the first data bit within
     the word. */
  aSrc    += aOffset / 32;
  src     += aOffset / 32;
  aOffset %= 32;

  /* The data is stored in not directly accessible memory area - load the block 
     containing the data first */
  if ( useReader )
    src = EwFlashAreaReaderProc( aSrc, 0 );

  /* Get the content of this data word and shift it, so the first compressed
     bit lies at the bit position 0. */
  data = *src++ >> aOffset;
  aSrc++;

  /* Repeat until all compressed bits are evaluated. */
  while ( aCount-- )
  {
    /* Determinate the next node in the tree. */
    if ( data & 1 ) inx = Tree[ inx ][ 1 ];
    else            inx = Tree[ inx ][ 0 ];

    /* A leaf node is reached? Store the uncompressed bits and start the
       next compressed sequence. */
    if ( inx > 15 )
    {
      #if EW_SURFACE_ROTATION == 0
        int x = ofs   % aWidth;
        int y = ofs++ / aWidth;
      #endif

      #if EW_SURFACE_ROTATION == 90
        int x = aHeight - ( ofs / aWidth   ) - 1;
        int y = ofs++ % aWidth;
      #endif

      #if EW_SURFACE_ROTATION == 180
        int x = aWidth  - ( ofs   % aWidth ) - 1;
        int y = aHeight - ( ofs++ / aWidth ) - 1;
      #endif

      #if EW_SURFACE_ROTATION == 270
        int x = ofs / aWidth;
        int y = aWidth - ( ofs++ % aWidth ) - 1;
      #endif

      inx -= 16;
      *( dest + y * pitch + x ) = (unsigned char)(( inx & 0x01 )? 0xFF : 0x00 );

      /* Is there a space to take one more? */
      if ( ofs < size )
      {
        #if EW_SURFACE_ROTATION == 0
          int x = ofs   % aWidth;
          int y = ofs++ / aWidth;
        #endif

        #if EW_SURFACE_ROTATION == 90
          int x = aHeight - ( ofs / aWidth   ) - 1;
          int y = ofs++ % aWidth;
        #endif

        #if EW_SURFACE_ROTATION == 180
          int x = aWidth  - ( ofs   % aWidth ) - 1;
          int y = aHeight - ( ofs++ / aWidth ) - 1;
        #endif

        #if EW_SURFACE_ROTATION == 270
          int x = ofs / aWidth;
          int y = aWidth - ( ofs++ % aWidth ) - 1;
        #endif

        *( dest + y * pitch + x ) = (unsigned char)(( inx & 0x02 )? 0xFF : 0x00 );
      }

      /* Is there a space to take one more? */
      if ( ofs < size )
      {
        #if EW_SURFACE_ROTATION == 0
          int x = ofs   % aWidth;
          int y = ofs++ / aWidth;
        #endif

        #if EW_SURFACE_ROTATION == 90
          int x = aHeight - ( ofs / aWidth   ) - 1;
          int y = ofs++ % aWidth;
        #endif

        #if EW_SURFACE_ROTATION == 180
          int x = aWidth  - ( ofs   % aWidth ) - 1;
          int y = aHeight - ( ofs++ / aWidth ) - 1;
        #endif

        #if EW_SURFACE_ROTATION == 270
          int x = ofs / aWidth;
          int y = aWidth - ( ofs++ % aWidth ) - 1;
        #endif

        *( dest + y * pitch + x ) = (unsigned char)(( inx & 0x04 )? 0xFF : 0x00 );
      }

      /* Is there a space to take one more? */
      if ( ofs < size )
      {
        #if EW_SURFACE_ROTATION == 0
          int x = ofs   % aWidth;
          int y = ofs++ / aWidth;
        #endif

        #if EW_SURFACE_ROTATION == 90
          int x = aHeight - ( ofs / aWidth   ) - 1;
          int y = ofs++ % aWidth;
        #endif

        #if EW_SURFACE_ROTATION == 180
          int x = aWidth  - ( ofs   % aWidth ) - 1;
          int y = aHeight - ( ofs++ / aWidth ) - 1;
        #endif

        #if EW_SURFACE_ROTATION == 270
          int x = ofs / aWidth;
          int y = aWidth - ( ofs++ % aWidth ) - 1;
        #endif

        *( dest + y * pitch + x ) = (unsigned char)(( inx & 0x08 )? 0xFF : 0x00 );
      }

      inx = 0;
    }
      
    /* Continue with the next bit - if all bits are processed, get the
       content of the next word. */
    if (( aOffset = ( aOffset + 1 )) & 0x1F )
      data >>= 1;
    else
    {
      /* The data from the previously loaded block is processed. Get the next 
         block. */
      if ( useReader && !((unsigned long)aSrc & ( EwFlashAreaBlockSize - 1 )))
        src = EwFlashAreaReaderProc( aSrc, 0 );

      data = *src++;
      aSrc++;
    }
  }
}


/* The following function decompresses aCount bits from the bit stream aSrc
   starting at the position aOffset and stores the decompressed data in the
   memory area aDest. The parameter aWidth and aHeight determine the resulting
   size of the glyph. */
static void Decompress2( const unsigned int* aSrc, XSurfaceMemory* aDest,
  int aWidth, int aHeight, int aOffset, int aCount )
{
  static const unsigned char trans[] = { 0x00, 0x55, 0xAA, 0xFF };

  unsigned int        data;
  int                 inx       = 0;
  const unsigned int* src       = aSrc;
  unsigned char*      dest      = aDest->Pixel1;
  int                 pitch     = aDest->Pitch1Y;
  int                 ofs       = 0;
  int                 size      = aWidth * aHeight;
  int                 useReader = EwFlashAreaReaderProc && 
                                   ((void*)aSrc >= EwFlashAreaStartAddress ) && 
                                   ((void*)aSrc <= EwFlashAreaEndAddress );

  /* Determinate the address of the data word where the compressed bit-
     stream begins and calculate the offset to the first data bit within
     the byte. */
  aSrc    += aOffset / 32;
  src     += aOffset / 32;
  aOffset %= 32;

  /* The data is stored in not directly accessible memory area - load the block 
     containing the data first */
  if ( useReader )
    src = EwFlashAreaReaderProc( aSrc, 0 );

  /* Get the content of this data word and shift it, so the first compressed
     bit lies at the bit position 0. */
  data = *src++ >> aOffset;
  aSrc++;

  /* Repeat until all compressed bits are evaluated. */
  while ( aCount-- )
  {
    /* Determinate the next node in the tree. */
    if ( data & 1 ) inx = Tree[ inx ][ 1 ];
    else            inx = Tree[ inx ][ 0 ];

    /* A leaf node is reached? Store the uncompressed bits and start the
       next compressed sequence. */
    if ( inx > 15 )
    {
      #if EW_SURFACE_ROTATION == 0
        int x = ofs   % aWidth;
        int y = ofs++ / aWidth;
      #endif

      #if EW_SURFACE_ROTATION == 90
        int x = aHeight - ( ofs / aWidth   ) - 1;
        int y = ofs++ % aWidth;
      #endif

      #if EW_SURFACE_ROTATION == 180
        int x = aWidth  - ( ofs   % aWidth ) - 1;
        int y = aHeight - ( ofs++ / aWidth ) - 1;
      #endif

      #if EW_SURFACE_ROTATION == 270
        int x = ofs / aWidth;
        int y = aWidth - ( ofs++ % aWidth ) - 1;
      #endif

      inx -= 16;
      *( dest + y * pitch + x ) = trans[ inx & 0x03 ];

      /* Is there a space to take one more? */
      if ( ofs < size )
      {
        #if EW_SURFACE_ROTATION == 0
          int x = ofs   % aWidth;
          int y = ofs++ / aWidth;
        #endif

        #if EW_SURFACE_ROTATION == 90
          int x = aHeight - ( ofs / aWidth   ) - 1;
          int y = ofs++ % aWidth;
        #endif

        #if EW_SURFACE_ROTATION == 180
          int x = aWidth  - ( ofs   % aWidth ) - 1;
          int y = aHeight - ( ofs++ / aWidth ) - 1;
        #endif

        #if EW_SURFACE_ROTATION == 270
          int x = ofs / aWidth;
          int y = aWidth - ( ofs++ % aWidth ) - 1;
        #endif

        *( dest + y * pitch + x ) = trans[ inx >> 2 ];
      }

      inx = 0;
    }
      
    /* Continue with the next bit - if all bits are processed, get the
       content of the next word. */
    if (( aOffset = ( aOffset + 1 )) & 0x1F )
      data >>= 1;
    else
    {
      /* The data from the previously loaded block is processed. Get the next 
         block. */
      if ( useReader && !((unsigned long)aSrc & ( EwFlashAreaBlockSize - 1 )))
        src = EwFlashAreaReaderProc( aSrc, 0 );

      data = *src++;
      aSrc++;
    }
  }
}


/* The following function decompresses aCount bits from the bit stream aSrc
   starting at the position aOffset and stores the decompressed data in the
   memory area aDest. The parameter aWidth and aHeight determine the resulting
   size of the glyph. */
static void Decompress4( const unsigned int* aSrc, XSurfaceMemory* aDest,
  int aWidth, int aHeight, int aOffset, int aCount )
{
  unsigned int        data;
  int                 inx       = 0;
  const unsigned int* src       = aSrc;
  unsigned char*      dest      = aDest->Pixel1;
  int                 pitch     = aDest->Pitch1Y;
  int                 ofs       = 0;
  int                 useReader = EwFlashAreaReaderProc && 
                                   ((void*)aSrc >= EwFlashAreaStartAddress ) && 
                                   ((void*)aSrc <= EwFlashAreaEndAddress );

  /* Disable warnings */
  #if ( EW_SURFACE_ROTATION != 90 ) && ( EW_SURFACE_ROTATION != 180 )
    EW_UNUSED_ARG( aHeight );
  #endif

  /* Determinate the address of the data word where the compressed bit-
     stream begins and calculate the offset to the first data bit within
     the word. */
  aSrc    += aOffset / 32;
  src     += aOffset / 32;
  aOffset %= 32;

  /* The data is stored in not directly accessible memory area - load the block 
     containing the data first */
  if ( useReader )
    src = EwFlashAreaReaderProc( aSrc, 0 );

  /* Get the content of this data word and shift it, so the first compressed
     bit lies at the bit position 0. */
  data = *src++ >> aOffset;
  aSrc++;

  /* Repeat until all compressed bits are evaluated. */
  while ( aCount-- )
  {
    /* Determinate the next node in the tree. */
    if ( data & 1 ) inx = Tree[ inx ][ 1 ];
    else            inx = Tree[ inx ][ 0 ];

    /* A leaf node is reached? Store the uncompressed bits and start the
       next compressed sequence. */
    if ( inx > 15 )
    {
      #if EW_SURFACE_ROTATION == 0
        int x = ofs   % aWidth;
        int y = ofs++ / aWidth;
      #endif

      #if EW_SURFACE_ROTATION == 90
        int x = aHeight - ( ofs / aWidth   ) - 1;
        int y = ofs++ % aWidth;
      #endif

      #if EW_SURFACE_ROTATION == 180
        int x = aWidth  - ( ofs   % aWidth ) - 1;
        int y = aHeight - ( ofs++ / aWidth ) - 1;
      #endif

      #if EW_SURFACE_ROTATION == 270
        int x = ofs / aWidth;
        int y = aWidth - ( ofs++ % aWidth ) - 1;
      #endif

      inx -= 16;
      *( dest + y * pitch + x ) = (unsigned char)( inx | ( inx << 4 ));
      inx = 0;
    }
      
    /* Continue with the next bit - if all bits are processed, get the
       content of the next word. */
    if (( aOffset = ( aOffset + 1 )) & 0x1F )
      data >>= 1;
    else
    {
      /* The data from the previously loaded block is processed. Get the next 
         block. */
      if ( useReader && !((unsigned long)aSrc & ( EwFlashAreaBlockSize - 1 )))
        src = EwFlashAreaReaderProc( aSrc, 0 );

      data = *src++;
      aSrc++;
    }
  }
}


/* The following helper function combines the pixel of upper rows with the 
   pixel of the lower rows. */
static void XOrRows( XSurfaceMemory* aDest, int aWidth, int aHeight )
{
  unsigned char* dest  = aDest->Pixel1;
  int            pitch = aDest->Pitch1Y;

  #if EW_SURFACE_ROTATION == 0
  {
    unsigned char* dest1 = dest;
    unsigned char* dest2 = dest1 + pitch;
    int            width;

    for ( aHeight--; aHeight > 0; aHeight-- )
    {
      for ( width = aWidth; width > 0; width-- )
        *dest2++ ^= *dest1++;

      dest1 += pitch - aWidth;
      dest2 += pitch - aWidth;
    }
  }
  #endif

  #if EW_SURFACE_ROTATION == 90
  {
    unsigned char* dest1 = dest + aHeight - 1;
    unsigned char* dest2 = dest1 - 1;
    int            width;

    for ( aHeight--; aHeight > 0; aHeight-- )
    {
      for ( width = aWidth; width > 0; width-- )
      {
        *dest2 ^= *dest1;
        dest1 += pitch;
        dest2 += pitch; 
      }

      dest1 -= aWidth * pitch + 1;
      dest2 -= aWidth * pitch + 1;
    }
  }
  #endif

  #if EW_SURFACE_ROTATION == 180
  {
    unsigned char* dest1 = dest  + ( pitch * ( aHeight - 1 )) + aWidth - 1;
    unsigned char* dest2 = dest1 - pitch;
    int            width;

    for ( aHeight--; aHeight > 0; aHeight-- )
    {
      for ( width = aWidth; width > 0; width-- )
        *dest2-- ^= *dest1--;

      dest1 -= pitch - aWidth;
      dest2 -= pitch - aWidth;
    }
  }
  #endif

  #if EW_SURFACE_ROTATION == 270
  {
    unsigned char* dest1 = dest + ( aWidth - 1 ) * pitch;
    unsigned char* dest2 = dest1 + 1;
    int            width;

    for ( aHeight--; aHeight > 0; aHeight-- )
    {
      for ( width = aWidth; width > 0; width-- )
      {
        *dest2 ^= *dest1;
        dest1 -= pitch;
        dest2 -= pitch; 
      }

      dest1 += aWidth * pitch + 1;
      dest2 += aWidth * pitch + 1;
    }
  }
  #endif
}


/* The following function processes the curve data specified in aStartCurves..
   aEndCurves and rasters from the available information a glyph bitmap in
   memory aMemory. Returns != 0 if successful. */
static int RasterGlyph( XSurfaceMemory* aMemory, const XFntGlyphRes* aGlyph,
  int aFontWidth, int aFontHeight, short aVecH, const short* aCurvesStart,
  const short* aCurvesEnd )
{
  const short* curves      = aCurvesStart;
  int          size        = 0;
  short        x0          = 0;
  short        y0          = 0;
  short        vecH2       = aVecH >> 1;
  short        originX     = aGlyph->OriginX;
  short        originY     = aGlyph->OriginY;
  int          pixelWidth  = (( aGlyph->Width  * aFontWidth  ) + vecH2 ) / aVecH;
  int          pixelHeight = (( aGlyph->Height * aFontHeight ) + vecH2 ) / aVecH;
  int          useReader   = USE_FLASH_READER( curves );
  int*         paths;
  int*         begPath;
  int*         curPath;
  char*        ptr;
  int          h;

  /* Round up the coordinates to the next pixel */
  originX = (( aFontWidth  *  originX ) + vecH2 ) / aVecH;
  originY = (( aFontHeight *  originY ) - vecH2 ) / aVecH;
  originX = ( originX * aVecH + ( aFontWidth  >> 1 )) / aFontWidth;
  originY = ( originY * aVecH - ( aFontHeight >> 1 )) / aFontHeight;

  /* If rotated exchange width and height */
  #if ( EW_SURFACE_ROTATION == 90 ) || ( EW_SURFACE_ROTATION == 270 )
    h           = pixelWidth;
    pixelWidth  = pixelHeight;
    pixelHeight = h;
  #endif

  /* First pass: estimate the memory size to accomodate the path data */
  for ( ; curves < aCurvesEnd; curves++ )
  {
    const short* opCode = curves;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( useReader )
      opCode = (const short*)EwFlashAreaReaderProc( opCode, sizeof( *opCode ));

    switch ( *opCode & 0xF )
    {
      case 1 : /* Start of a new polygnon (new sub-path) */
      {
        size   += 5;
        curves += 2;
      }
      break;

      case 2 : /* One or more straight line segments */
      {
        size   += ( *opCode >> 4 ) * 2;
        curves += ( *opCode >> 4 ) * 2;
      }
      break;

      case 3 : /* One or more quadratic splines */
      {
        int count = *opCode >> 4;

        /* Process all splines one after another */
        for ( curves++; count > 1; count--, curves += 3 )
        {
          const short* len = curves + 2;
          short        noOfEdges;

          /* Not directly accessible memory area? Map the content in CPU address
             space. */
          if ( useReader )
            len = (const short*)EwFlashAreaReaderProc( len, sizeof( *len ));

          noOfEdges = ((( *len * ( aFontWidth + aFontHeight )) + vecH2 ) / aVecH ) / 8;

          /* Very small curve. Add some edges so that it is more precise */
          if ( noOfEdges < 8 )
            noOfEdges += 2;

          size += noOfEdges * 2;
        }

        curves++;
      }
      break;

      case 0  : break;
      default : return 0;
    }
  }

  /* For the end of path */
  size++;

  /* Allocate temporary memory for the path data */
  do
    paths = EwAlloc( size * sizeof( int ));
  while ( !paths && EwImmediateReclaimMemory( 81 ));

  if ( !paths )
  {
    EwError( 81 );
    return 0;
  }

  curPath = paths;
  begPath = paths;

  /* Track the temporary used memory */
  EwResourcesMemory += sizeof( size * sizeof( int ));

  /* Also track the max. memory pressure */
  if ( EwResourcesMemory > EwResourcesMemoryPeak )
    EwResourcesMemoryPeak = EwResourcesMemory;

  if (( EwObjectsMemory + EwStringsMemory + EwResourcesMemory ) > EwMemoryPeak )
    EwMemoryPeak = EwObjectsMemory + EwStringsMemory + EwResourcesMemory;

  /* Second pass: Synthese the path data */
  for ( curves = aCurvesStart; curves < aCurvesEnd; curves++ )
  {
    const short* opCode = curves;

    /* Not directly accessible memory area? Map the content in CPU address space. */
    if ( useReader )
      opCode = (const short*)EwFlashAreaReaderProc( opCode, sizeof( *opCode ));

    switch ( *opCode & 0xF )
    {
      case 1 : /* Start of a new polygnon (new sub-path) */
      {
        const short* data = curves + 1;

        /* Not directly accessible memory area? Map the content in CPU address space. */
        if ( useReader )
          data = (const short*)EwFlashAreaReaderProc( data, sizeof( *data ) * 2 );

        /* Complete the preceding sub-path */
        if ( curPath > begPath )
        {
          *curPath++ = begPath[1];
          *curPath++ = begPath[2];
          *begPath = (( curPath - begPath - 1 ) / 2 ) - 1;
        }

        x0         = data[0];
        y0         = data[1];
        begPath    = curPath++;
        *curPath++ = (((( x0 - originX  ) * aFontWidth  ) << 4 ) + vecH2 ) / aVecH;
        *curPath++ = (((( -originY - y0 ) * aFontHeight ) << 4 ) + vecH2 ) / aVecH;
        curves    += 2;
      }
      break;

      case 2 : /* One or more straight line segments */
      {
        int count = *opCode >> 4;

        for ( ; count > 0; count-- )
        {
          const short* data = curves + 1;

          /* Not directly accessible memory area? Map the content in CPU address space. */
          if ( useReader )
            data = (const short*)EwFlashAreaReaderProc( data, sizeof( *data ) * 2 );

          x0         = data[0];
          y0         = data[1];
          *curPath++ = (((( x0 - originX  ) * aFontWidth  ) << 4 ) + vecH2 ) / aVecH;
          *curPath++ = (((( -originY - y0 ) * aFontHeight ) << 4 ) + vecH2 ) / aVecH;
          curves    += 2;
        }
      }
      break;

      case 3 : /* One or more quadratic splines */
      {
        int          count = *opCode >> 4;
        const short* data  = curves + 1;
        short        x1;
        short        y1;

        /* Not directly accessible memory area? Map the content in CPU address space. */
        if ( useReader )
          data = (const short*)EwFlashAreaReaderProc( data, sizeof( *data ) * 2 );

        x1      = data[0];
        y1      = data[1];
        curves += 2;

        /* Process all splines one after another */
        for ( ; count > 1; count-- )
        {
          short          x2;
          short          y2;
          short          xe;
          short          ye;
          short          noOfEdges;
          unsigned short s;
          unsigned short t;

          data = curves + 1;

          /* Not directly accessible memory area? Map the content in CPU address space. */
          if ( useReader )
            data = (const short*)EwFlashAreaReaderProc( data, sizeof( *data ) * 3 );

          x2        = data[1];
          y2        = data[2];
          xe        = x2;
          ye        = y2;
          noOfEdges = ((( data[0] * ( aFontWidth + aFontHeight )) + vecH2 ) / aVecH ) / 8;
          curves   += 3;

          /* Very small curve. Add some edges so that it is more precise */
          if ( noOfEdges < 8 )
            noOfEdges += 2 ;

          /* Single step on the Bezier curve */
          s = 0x10000 / noOfEdges;

          if ( count > 2 )
          {
            xe = ( x1 + x2 ) >> 1;
            ye = ( y1 + y2 ) >> 1;
          }

          /* Compose the spline of straight line segments (edges) */
          for ( t = s; noOfEdges > 1; t += s, noOfEdges-- )
          {
            unsigned short nt  = 0x10000 - t;
            unsigned short nt2 = ( nt     * nt ) >> 16;
            unsigned short t2  = ( t      * t  ) >> 16;
            unsigned short f2  = ( 2 * nt * t  ) >> 16;
            int            x   = ( nt2 * x0 + f2 * x1 + t2 * xe ) >> 12;
            int            y   = ( nt2 * y0 + f2 * y1 + t2 * ye ) >> 12;

            *curPath++ = ((( x - ( originX << 4   )) * aFontWidth  ) + vecH2 ) / aVecH;
            *curPath++ = (((( -originY << 4 ) - y  ) * aFontHeight ) + vecH2 ) / aVecH;
          }

          /* Store the end position of the curve */
          *curPath++ = (((( xe - originX  ) * aFontWidth  ) << 4 ) + vecH2 ) / aVecH;
          *curPath++ = (((( -originY - ye ) * aFontHeight ) << 4 ) + vecH2 ) / aVecH;

          /* Parameters for the next spline */
          x1 = x2;
          y1 = y2;
          x0 = xe;
          y0 = ye;
        }
      }
      break;
    }
  }

  /* Complete the last processed sub-path */
  if ( curPath > begPath )
  {
    *curPath++ = begPath[1];
    *curPath++ = begPath[2];
    *begPath = (( curPath - begPath - 1 ) / 2 ) - 1;
  }

  /* End of path */
  *curPath = 0;

  #if EW_SURFACE_ROTATION == 90
  {
    int* tmpPaths = paths;
    int  noOfEdges;

    /* Process all sub-paths */
    while ( *tmpPaths > 0 )
      for ( noOfEdges = *tmpPaths++; noOfEdges >= 0; noOfEdges--, tmpPaths += 2 )
      {
        int x = tmpPaths[0];
        tmpPaths[0] = ( pixelWidth << 4 ) - tmpPaths[1]; 
        tmpPaths[1] = x;
      }
  }
  #endif

  #if EW_SURFACE_ROTATION == 180
  {
    int* tmpPaths = paths;
    int  noOfEdges;

    while ( *tmpPaths > 0 )
      for ( noOfEdges = *tmpPaths++; noOfEdges >= 0; noOfEdges--, tmpPaths += 2 )
      {
        tmpPaths[0] = ( pixelWidth  << 4 ) - tmpPaths[0]; 
        tmpPaths[1] = ( pixelHeight << 4 ) - tmpPaths[1]; 
      }
  }
  #endif

  #if EW_SURFACE_ROTATION == 270
  {
    int* tmpPaths = paths;
    int  noOfEdges;

    while ( *tmpPaths > 0 )
      for ( noOfEdges = *tmpPaths++; noOfEdges >= 0; noOfEdges--, tmpPaths += 2 )
      {
        int y = tmpPaths[1];
        tmpPaths[1] = ( pixelHeight << 4 ) - tmpPaths[0]; 
        tmpPaths[0] = y;
      }
  }
  #endif

  /* To avoid ugly looking (clipped) glyphs the glyph area is enhanced by few
     pixel. */
  pixelWidth  += 2;
  pixelHeight += 2;

  /* Clear the pixel memory before rasterizing the glyph */
  for ( ptr = aMemory->Pixel1, h = 0; h < pixelHeight; h++, ptr += aMemory->Pitch1Y )
    EwZero( ptr, aMemory->Pitch1X * pixelWidth );

  /* Run the raster algorithm to render from the prepared path data a glyph image */
  EwRasterAlpha8Polygon( aMemory, paths, 0, 0, pixelWidth, pixelHeight, -16,
                         -16, 1, 1 );

  /* Release the path data and track the temporary used memory */
  EwFree( paths );
  EwResourcesMemory -= sizeof( size * sizeof( int ));

  return 1;
}


/* Helper function to get the pointer to the name associated to the resource. */
static const char* GetResourceName( const XFntRes* aResource )
{
  const XFntRes* res    = aResource;
  #ifdef EW_USE_BLOB_DATA
    int          isBlob = res->MagicNo == EW_MAGIC_NO_FONT_BLOB;
  #endif
  const char*    name   = RES_PTR( Name );
  int            count  = 0;

  /* Can the CPU access the resource name directly? Then simply return the
     pointer to the name. */
  if ( !USE_FLASH_READER( name ))
    return name;

  /* Otherwise estimate the length of the name in characters looking for the
     zero terminator. */
  while ( *(const char*)EwFlashAreaReaderProc( name + count, 0 ))
    count++;

  /* Map the entire name in CPU address space and return the pointer to
     this memory. */
  return (const char*)EwFlashAreaReaderProc( name, count + 1 );
}


/* msy, pba */
