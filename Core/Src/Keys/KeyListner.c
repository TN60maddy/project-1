/**
 * @file KeyListner.c
 * @brief Source file for the KeyListner module.
 *
 * This module implements a FreeRTOS software timer that scans three keys (with debounce logic)
 * every 200 ms. When a valid key press is detected, a message is sent to the KeyListner task.
 * In the case of an OPEN/CLOSE button press, the message is forwarded to the DoorHandle module.
 *
 * @author
 *         Radhakrishnan Rajaram
 * @company
 *         Aria Innovations
 * @date
 *         2025-02-11
 * @revision History:
 *         - 1.0 2025-02-11: Initial version.
 */

#include "KeyListner.h"
#include "DoorHandler.h"         /* For forwarding OPEN/CLOSE messages */
#include "stm32h7xx_hal.h"      /* HAL header for STM32H7 series */

/* FreeRTOS objects */
static TimerHandle_t xKeyScanTimer = NULL;
static QueueHandle_t xKeyQueue = NULL;
static TaskHandle_t xKeyListnerTaskHandle = NULL;

/* Debounce configuration: number of consecutive samples required */
#define DEBOUNCE_THRESHOLD 2

/**
 * @brief Structure to hold debounce information for each button.
 */
typedef struct {
    uint16_t       pin;          /**< GPIO pin number */
    GPIO_TypeDef  *port;         /**< GPIO port */
    uint8_t        debounceCount;/**< Current debounce counter */
    uint8_t        pressedFlag;  /**< Flag to indicate if press has been reported */
    KeyMessage_t   keyMsg;       /**< Message associated with this button */
} ButtonDebounce_t;

/* Array of button configurations */
static ButtonDebounce_t buttons[] = {
    {GPIO_PIN_2, GPIOH, 0, 0, KEY_MSG_STOP},        /**< STOP_BTN on PH2 */
    {GPIO_PIN_3, GPIOH, 0, 0, KEY_MSG_OPEN_CLOSE},    /**< OPEN/CLOSE_BTN on PH3 */
    {GPIO_PIN_4, GPIOH, 0, 0, KEY_MSG_PWR}            /**< PWR_BTN on PH4 */
};

#define NUM_BUTTONS (sizeof(buttons) / sizeof(buttons[0]))

/**
 * @brief Initializes the GPIO pins for the buttons.
 *
 * Configures PH2, PH3, and PH4 as input pins with internal pull-up resistors.
 */
static void Buttons_GPIO_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};

    /* Enable clock for GPIOH */
    __HAL_RCC_GPIOH_CLK_ENABLE();

    /* Configure pins PH2, PH3, PH4 as input*/
    GPIO_InitStruct.Pin = GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_4;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
}

/**
 * @brief Software timer callback for key scanning.
 *
 * This callback is executed every 200 ms. It reads the state of each button, applies debounce
 * logic, and sends a key message (via a queue) when a valid press is detected.
 *
 * @param xTimer Timer handle (unused).
 */
static void vKeyScanTimerCallback(TimerHandle_t xTimer)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    /* Iterate over each button */
    for (int i = 0; i < NUM_BUTTONS; i++) {
        /* Read button state.
         * Assumes active low: button pressed if pin state is GPIO_PIN_RESET.
         */
        GPIO_PinState pinState = HAL_GPIO_ReadPin(buttons[i].port, buttons[i].pin);
        if (pinState == GPIO_PIN_RESET) {  /* Button is pressed */
            if (buttons[i].debounceCount < DEBOUNCE_THRESHOLD) {
                buttons[i].debounceCount++;
            }
            if ((buttons[i].debounceCount >= DEBOUNCE_THRESHOLD) && (buttons[i].pressedFlag == 0)) {
                /* Valid press detected; mark as reported and send message */
                buttons[i].pressedFlag = 1;
                KeyMessage_t msg = buttons[i].keyMsg;
                xQueueSendFromISR(xKeyQueue, &msg, &xHigherPriorityTaskWoken);
            }
        } else {
            /* Button is released; reset debounce counter and flag */
            buttons[i].debounceCount = 0;
            buttons[i].pressedFlag = 0;
        }
    }
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

/**
 * @brief KeyListner task.
 *
 * This task waits on a queue for key messages generated by the key scan timer callback.
 * When a message is received, the task processes it. In particular, if an OPEN/CLOSE
 * message is received, it calls the DoorHandle module to send a door operation message.
 *
 * @param argument Not used.
 */
static void vKeyListnerTask(void *argument)
{
    KeyMessage_t receivedMsg;
    (void) argument;

    for (;;) {
        if (xQueueReceive(xKeyQueue, &receivedMsg, portMAX_DELAY) == pdPASS) {
            switch (receivedMsg) {
                case KEY_MSG_STOP:
                    /* Process STOP button press (e.g., logging or other action) */
                    break;
                case KEY_MSG_OPEN_CLOSE:
                    /* Forward OPEN/CLOSE button press to DoorHandle task */
                    DoorHandlerSendMessage();
                    break;
                case KEY_MSG_PWR:
                    /* Process POWER button press if needed */
                    break;
                default:
                    break;
            }
        }
    }
}

/**
 * @brief Error handler.
 *
 * This function is executed in case of a critical error.
 */
static void KeyListnerError_Handler(void)
{
    /* User may add their own implementation to report errors */
    while (1)
    {
        /* In an actual application, an LED might be toggled here */
    }
}

/**
 * @brief Initializes the KeyListner module.
 *
 * This function performs the following:
 *  - Initializes the GPIO pins for the buttons.
 *  - Creates a FreeRTOS queue for key messages.
 *  - Creates a FreeRTOS software timer that calls the key scan callback every 200 ms.
 *  - Creates the KeyListner task.
 */
void KeyListnerInit(void)
{
    /* Initialize button GPIOs */
    Buttons_GPIO_Init();

    /* Create the key message queue */
    xKeyQueue = xQueueCreate(10, sizeof(KeyMessage_t));
    if (xKeyQueue == NULL) {
        /* Queue creation failed */
    	KeyListnerError_Handler();
    }

    /* Create a periodic software timer with a period of 200 ms */
    xKeyScanTimer = xTimerCreate("KeyScanTimer",
                                 pdMS_TO_TICKS(200),
                                 pdTRUE,
                                 (void *)0,
                                 vKeyScanTimerCallback);
    if (xKeyScanTimer == NULL) {
        /* Timer creation failed */
    	KeyListnerError_Handler();
    }
    if (xTimerStart(xKeyScanTimer, 0) != pdPASS) {
        /* Timer start failed */
    	KeyListnerError_Handler();
    }

    /* Create the KeyListner task */
    if (xTaskCreate(vKeyListnerTask,
                    "KeyListnerTask",
                    128,
                    NULL,
                    tskIDLE_PRIORITY + 3,
                    &xKeyListnerTaskHandle) != pdPASS)
    {
        /* Task creation failed */
    	KeyListnerError_Handler();
    }
}


